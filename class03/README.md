# 3回

## システムコール

プロセスという仕組みは仮想的なもの。ハードウェアで実現しているわけではない。

プロセス←→カーネル　のやりとり（通信）

システムコールは311個!!

system calls: `man 2 syscalls`

## exit()

終了する.

CやJavaでMainが終了したあとにはexit()が実行されている。

## fork()

分岐、別れる

プロセスが別れる。プロセスのクローンが作成される。

人格(pid)は別のもの。まさに分身の術。

**プロセスが無いとコマンドは実行できない。**

---

**マシンの電源を入れると何が起きているか考えてみよう**

世界最初のプロセス(pid:0)を作成して実行する

プロセス(pid:0)から派生してプロセスが生まれる。

辿っていくと1つのプロセスにたどり着く。

**逆にkernelは何も変化しない**

プロセスを誕生させるただ１つのシステムコール`fork()`

## creat()

語尾にeがない

## execve()

かなり特殊。これを出した途端に別のプログラムとして実行。

    ## オリジナルのシェルを作成する

    fork()でプロセスを1つ作成する

    execve()でコマンドを実現するプログラムを実行する

    大体、プログラム(シェル)は`/usr/bin/`や`/bin/`に置いてある

    探す場所は`echo $PATH`で見つかる

## その他

昔のUnixは`chdir()`ってコマンドを打ち込んだ...

ファイルシステム系のシステムコールの大半はファイルシステム関係.

## インターフェース(I/O)

I/O装置

- NIC(ネットワーク)
- キーボード
- HDD

ReadとWriteはパワフルなシステムコール

## Linuxのファイルシステム

プログラムがファイルにアクセスするには、

1. open()でfdを得る
2. read()やwrite()で入出力
3. close()でfdを閉じる

ファイルディルクリプタ

- 0から始める整数値(int)
- ファイルを開くたびに大きな番号が割り当てられる
- 標準入力の実態はfd=0であらかじめ開かれたファイル

`System.out.println()`では fd=1に指定した文字列を書き出している。

動画の読み込みも`read()`が大量に行われている。

[E.2.29. /proc/version](https://access.redhat.com/documentation/ja-JP/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-version.html)

## ファイルシステムの仕様補足

- プロセスはカレントディレクトリを持つ
- 順番とは異なる部分をアクセスしたい場合は, `lseek()`を利用

## オリジナルの`cat`を使う

`PATH=$PATH:~/bin`

作業タイム

## システムコールの処理

プロセス毎にメモリ空間を持っている。

どのプロセスもメモリ空間は0番地から始まる


